<!DOCTYPE html>
<html lang="en">
<!-- 
This page has been mostly generated by chatgpt o1, including the art.
This site is not affiliated with or endorsed by Team Cherry.
-->
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Is silksong out yet?</title>
  
  <style>
    /* Reset and basic styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .steam-link {
    color: inherit; /* Use the same color as surrounding text */
      text-decoration: none; /* Remove underline */
    }

    .steam-link:hover {
      text-decoration: underline; /* Only underline on hover */
    }

    .steam-link:visited {
      color: inherit; /* Ensure color doesn't change after clicking */
    }


    /* Dark/gloomy animated gradient background */
    body {
      display: flex;                /* For vertical/horizontal centering */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: sans-serif;
      
      /* Gradient animation (darker theme) */
      background: linear-gradient(-45deg, #232526, #414345, #2c3e50, #000000);
      background-size: 400% 400%;
      animation: gradientBG 15s ease infinite;
      overflow: hidden;            
      position: relative;          /* So we can absolutely position the draggable item */
    }

    /* Keyframes for the background animation */
    @keyframes gradientBG {
      0%   { background-position: 0% 50%; }
      50%  { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    h1 {
      font-size: 4rem;
      margin-bottom: 1.5rem;
      color: #f0f0f0;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    /* Container for the centered elements */
    .container {
      text-align: center;
    }

    /* Box that shows random text on hover -- fixed width to prevent shifting */
    .hover-box {
      display: inline-block;
      width: 280px;             /* Fix width so the layout doesn't shift */
      border: 2px solid #555;
      background-color: #666;
      padding: 1.5rem 1rem;
      font-size: 1.2rem;
      color: #f0f0f0;
      transition: background-color 0.3s, color 0.3s;
      cursor: pointer;
      margin-bottom: 2rem;
    }
    .hover-box:hover {
      background-color: #222;
      color: #fff;
    }

    /* Draggable item styling */
    #draggableItem {
      position: absolute;
      left: 50px;               /* Initial x-position */
      top: 50px;                /* Initial y-position */
      width: 100px;             /* Adjust to your image size */
      height: auto;             /* Maintain aspect ratio */
      cursor: grab;             /* Grab cursor */
      user-select: none;        /* Prevent text selection while dragging */
    }
    #draggableItem:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Is <a href="https://store.steampowered.com/app/1030300/Hollow_Knight_Silksong/"
      target="_blank" rel="noopener noreferrer" class="steam-link">
      silksâ€‹ong
   </a> out yet?</h1>

    <div class="hover-box" id="hoverBox">Hover over me!</div>
  </div>

  <!-- Draggable .webp image (gravity-affected).-->
  <img id="draggableItem" src="silksongout.webp" alt="ANY TIME NOW" />

  <!-- JavaScript for random text on hover -->
  <script>
    const messages = [
      "No, not yet!",
      "Almost there!",
      "It's coming soon...",
      "Any time now...",
      "Check back later!",
      "Maybe tomorrow?",

      '<a href="https://store.steampowered.com/app/1030300/Hollow_Knight_Silksong/" target="_blank" rel="noopener noreferrer">Go check the Steam page now!</a>'
    ];
    
    const hoverBox = document.getElementById('hoverBox');
    const originalText = hoverBox.textContent;
  
    hoverBox.addEventListener('mouseover', () => {
    const randomIndex = Math.floor(Math.random() * messages.length);
    const message = messages[randomIndex];

    // Update innerHTML to show the message
    hoverBox.innerHTML = message;

    // If the message is a link (contains "<a>"), don't update the title
    if (!message.includes("<a")) {
      document.title = message;
    }
  });
    
    hoverBox.addEventListener('mouseout', () => {
      // Revert to just text, not HTML
      hoverBox.textContent = originalText;
    });
  </script>

  <!-- JavaScript for gravity, auto-bounce, and smoother dragging via pointer events -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const draggableItem = document.getElementById('draggableItem');
  
      // ----------------------------------
      // 1) Position and velocities
      // ----------------------------------
      let x = draggableItem.offsetLeft;
      let y = draggableItem.offsetTop;
      let xVelocity = 0;
      let yVelocity = 0;
  
      const gravity = 0.2;      // gentler gravity
      const friction = 0.98;    // optional horizontal friction
  
      // ----------------------------------
      // 2) Throw parameter (max speed)
      // ----------------------------------
      function getMaxSpeed() {
        // You can adjust this constant if you want a faster/slower max speed.
        return 15;
      }
      let maxSpeed = getMaxSpeed();
  
      // ----------------------------------
      // 3) Dragging state
      // ----------------------------------
      let isDragging = false;
      let offsetX = 0;
      let offsetY = 0;
  
      // For velocity calculations from pointer events
      let lastPointerX = 0;
      let lastPointerY = 0;
      let lastPointerTime = 0;
  
      // ----------------------------------
      // 4) Idle timer (for jump)
      // ----------------------------------
      let idleTimer = null;
  
      function scheduleIdleJump() {
        clearIdleTimer();
        // Random delay between 3 and 7 seconds
        const randomDelay = 3000 + Math.random() * 4000;
        idleTimer = setTimeout(() => {
          if (!isDragging) {
            // Small jump
            yVelocity = -(2+(Math.random() * 10));
            xVelocity = (Math.random() > 0.5 ? -1 : 1) * -(2+(Math.random() * 10));
          }
          // Schedule the next jump
          scheduleIdleJump();
        }, randomDelay);
      }
  
      function clearIdleTimer() {
        if (idleTimer) {
          clearTimeout(idleTimer);
          idleTimer = null;
        }
      }
  
      // ----------------------------------
      // 5) Main physics loop
      // ----------------------------------
      function applyPhysics() {
        if (!isDragging) {
          // Apply gravity
          yVelocity += gravity;
          y += yVelocity;
  
          // Apply friction horizontally
          xVelocity *= friction;
          x += xVelocity;
  
          // Floor collision
          const floor = window.innerHeight - draggableItem.offsetHeight;
          if (y > floor) {
            y = floor;
            // Bounce factor
            yVelocity = -yVelocity * 0.3;
          }
  
          // Wall collisions (left/right)
          if (x < 0) {
            x = 0;
            xVelocity = -xVelocity * 0.3;
          } else if (x + draggableItem.offsetWidth > window.innerWidth) {
            x = window.innerWidth - draggableItem.offsetWidth;
            xVelocity = -xVelocity * 0.3;
          }
  
          // Move the item
          draggableItem.style.left = `${x}px`;
          draggableItem.style.top  = `${y}px`;
        }
        requestAnimationFrame(applyPhysics);
      }
      requestAnimationFrame(applyPhysics);
  
      // ----------------------------------
      // 6) Pointer Events
      // ----------------------------------
      draggableItem.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        draggableItem.setPointerCapture(e.pointerId);
  
        isDragging = true;
        offsetX = e.clientX - x;
        offsetY = e.clientY - y;
  
        // Reset pointer data
        lastPointerX = e.clientX;
        lastPointerY = e.clientY;
        lastPointerTime = e.timeStamp;
  
        // Stop any idle timer when user starts dragging
        clearIdleTimer();
      });
  
      draggableItem.addEventListener('pointermove', (e) => {
        if (isDragging) {
          e.preventDefault();
  
          // Follow pointer directly
          x = e.clientX - offsetX;
          y = e.clientY - offsetY;
          draggableItem.style.left = `${x}px`;
          draggableItem.style.top  = `${y}px`;
  
          // Compute velocity (in px/s)
          const dx = e.clientX - lastPointerX;
          const dy = e.clientY - lastPointerY;
          const dt = (e.timeStamp - lastPointerTime) / 1000; // ms -> s
  
          if (dt > 0) {
            xVelocity = dx / dt;
            yVelocity = dy / dt;
  
            // Cap the overall speed
            const speed = Math.hypot(xVelocity, yVelocity);
            if (speed > maxSpeed) {
              xVelocity = (xVelocity / speed) * maxSpeed;
              yVelocity = (yVelocity / speed) * maxSpeed;
            }
          }
  
          // Update last pointer data
          lastPointerX = e.clientX;
          lastPointerY = e.clientY;
          lastPointerTime = e.timeStamp;
        }
      });
  
      draggableItem.addEventListener('pointerup', (e) => {
        e.preventDefault();
        draggableItem.releasePointerCapture(e.pointerId);
        isDragging = false;
        // Start idle timer again once user stops dragging
        scheduleIdleJump();
      });
  
      draggableItem.addEventListener('pointercancel', (e) => {
        e.preventDefault();
        draggableItem.releasePointerCapture(e.pointerId);
        isDragging = false;
        // Also restart idle timer if pointer was canceled
        scheduleIdleJump();
      });
  
      // Recompute max speed on window resize
      window.addEventListener('resize', () => {
        maxSpeed = getMaxSpeed();
  
        // Make sure it doesn't clip through the floor on resize
        const floor = window.innerHeight - draggableItem.offsetHeight;
        if (y > floor) {
          y = floor;
          yVelocity = 0;
        }
      });
  
      // Start the first idle timer on load
      scheduleIdleJump();
    });
  </script>
  
</body>
<footer style="
  text-align: center; 
  position: absolute;
  bottom: 0; 
  color: rgba(9, 2, 65, 0.271); 
  font-size: 0.42rem; 
  margin-top: 2rem;
">
  <p style="margin: 0.4rem 0;">
    All code & artwork on this site is AI-generated (via ChatGPT).
    Not affiliated with or endorsed by any third party.
  </p>
</footer>
</html>
